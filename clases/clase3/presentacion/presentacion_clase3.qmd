---
title: "Sistema de InformaciÃ³n GeogrÃ¡fica (SIG)"
subtitle: "CreaciÃ³n y anÃ¡lisis de Mapas"
author: "MatÃ­as Deneken"
logo: "images/logo_ciir.jpg"
include-in-header:
  - text: |
      <style>
        .reveal .slides {
          padding-top: 0px !important;
        }
        .reveal h2 {
          margin-top: -20px !important;
        }
      </style>
footer: "SesiÃ³n 3: InteRculturales"
date: "2025-05-22"
date-format: long
format: 
  revealjs:
    incremental: true
    theme: simple
    width: 1600
    height: 900
    transition: slide
    slide-number: c/t
    chalkboard: true
    auto-stretch: false
callout-appearance: minimal
---

# Temario de hoy

1.  IntroducciÃ³n al SIG
2.  Paquetes en R
3.  UniÃ³n de bases de datos
4.  PrÃ¡ctica con datos ficticios
5.  ChileMapas
6.  CÃ³digo prÃ¡ctico

## Objetivo principal: Replicar estos mapas

::: columns
::: {.column width="50%"}
#### Mapa mundial

![](images/humilde-objetivo1.png){fig-align="center" width="496"}
:::

::: {.column width="50%"}
#### Mapa Chile y regiones

![](images/humilde-objetivo2.png.jpeg){fig-align="center" width="679"}
:::
:::

```{r, eval=TRUE}
library(tidyverse)
library(sf)
library(countrycode)
```

## Recapitulando

## Sistema de InformaciÃ³n GeogrÃ¡fica (SIG)

## Paquetes: ğŸ“¦ Â¿QuÃ© esÂ `sf`?

`sf`Â es unÂ **paquete de R**Â para trabajar conÂ **datos espaciales**Â (geogrÃ¡ficos) de manera moderna y eficiente. Su nombre viene deÂ **"simple features"**, un estÃ¡ndar internacional para representar datos espaciales (como puntos, lÃ­neas o polÃ­gonos) en bases de datos y software.

Te permite:

-   Leer y escribirÂ **archivos espaciales**Â como Shapefiles, GeoJSON, KML, etc.

-   Unir datos geogrÃ¡ficos con datos tabulares (como una comuna con su poblaciÃ³n).

-   HacerÂ **anÃ¡lisis espacial**Â (intersecciones, distancias, Ã¡reas, etc.).

-   Visualizar mapas fÃ¡cilmente conÂ `ggplot2::geom_sf()`Â oÂ `tmap`.

## Paquetes: ğŸ“¦ Â¿QuÃ© esÂ `sf`?

### ğŸ§© Tipos de geometrÃ­a

-   `POINT`: una ubicaciÃ³n (ej: una escuela).

-   `LINESTRING`: una lÃ­nea (ej: un rÃ­o).

-   `POLYGON`: una superficie cerrada (ej: una comuna o paÃ­s).

-   `MULTIPOLYGON`: varios polÃ­gonos juntos (ej: Chile continental + Rapa Nui).

### ğŸ”§ Funciones importantes del paqueteÂ `sf`

-   `st_read()`: lee archivos espaciales (como shapefiles).

-   `st_write()`: guarda archivos espaciales.

-   `st_geometry()`: accede a la geometrÃ­a de un objeto.

-   `st_crs()`: inspecciona o define el sistema de coordenadas.

-   `st_transform()`: cambia la proyecciÃ³n del mapa.

-   `st_join()`,Â `st_intersection()`: operaciones espaciales.

## Paquetes: ğŸ“¦ Â¿QuÃ© esÂ `sf`?

### ğŸ—ºï¸ Â¿Por quÃ© es Ãºtil?

Porque te permite combinar el mundo de laÂ **estadÃ­stica en R**Â con el anÃ¡lisis geogrÃ¡fico, sin salir del mismo entorno.Â 

| Componente             | Â¿QuÃ© hace?                                              |
|------------------------|---------------------------------------------------------|
| **Clase especial**     | Le dice a R cÃ³mo interpretar los datos como espaciales. |
| **ColumnaÂ `geometry`** | Guarda formas como puntos, polÃ­gonos, lÃ­neas.           |
| **`CRS`Â (proyecciÃ³n)** | Define cÃ³mo se ubica esa geometrÃ­a en el planeta.       |
| **MÃ©todos especiales** | Permite hacer joins, distancias, transformaciones, etc. |

## Paquete: countrycode

El paquete `countrycode` permite convertir nombres de paÃ­ses entre distintos sistemas de codificaciÃ³n estÃ¡ndar. Es muy Ãºtil para unir bases de datos internacionales o conectar datos con geometrÃ­as espaciales.

```{r, message=FALSE, eval=TRUE, echo=TRUE}
library(countrycode)
```

```{r, echo=TRUE}
countrycode("Chile", origin = "country.name", destination = "iso3c")
```

```{r, echo=TRUE}
names(countrycode::codelist)[1:10]
```

Algunas opciones de destination que puedes usar: \*

-   "iso3c" â†’ cÃ³digo de 3 letras (ej: CHL)

-   "iso2c" â†’ cÃ³digo de 2 letras (ej: CL) \* "continent" â†’ continente (ej: Americas)

-    "region" â†’ regiÃ³n del mundo segÃºn World Bank

-   "un.region.name" â†’ regiÃ³n segÃºn Naciones Unidas

-   "cldr.short.en" â†’ nombre corto en inglÃ©s (ej: Chile)

## Paquete: countrycode

```{r}
library(countrycode)
library(knitr)

# Crear tabla con distintas codificaciones para "Chile"
tabla_chile <- data.frame(
  atributo = c("Nombre (original)", "CÃ³digo ISO-3", "CÃ³digo ISO-2", "Continente", "RegiÃ³n", "RegiÃ³n ONU", "Nombre corto en inglÃ©s"),
  valor = c(
    "Chile",
    countrycode("Chile", "country.name", "iso3c"),
    countrycode("Chile", "country.name", "iso2c"),
    countrycode("Chile", "country.name", "continent"),
    countrycode("Chile", "country.name", "region"),
    countrycode("Chile", "country.name", "un.region.name"),
    countrycode("Chile", "country.name", "cldr.short.en")
  )
)

# Mostrar como tabla
kable(tabla_chile, caption = "Codificaciones para 'Chile' usando countrycode()")

```

## Paquete: R Natural Earth.

Es un paquete R que permiteÂ **descargar datos geogrÃ¡ficos del mundo**Â (paÃ­ses, estados, lÃ­neas costeras, rÃ­os, etc.) desde el proyectoÂ [Natural Earth](https://www.naturalearthdata.com/). Se usa mucho para crear mapas en R, especialmente conÂ `sf`Â yÂ `ggplot2`.

```{r}
library(rnaturalearth)

world <- ne_countries(scale = "medium", returnclass = "sf")

world |> select(iso_a3, geometry) |> head(2)
```

**Posee estadÃ­sticas de interÃ©s:**

-   Producto de Interno de Bruto

-   RegiÃ³n econÃ³mica (BRICS, OCDE, etc)

-   Espera de vida

## Entonces....

| Paquete         | Rol en el flujo de trabajo                  | AnalogÃ­a                         |
|-----------------|---------------------------------------------|----------------------------------|
| `sf`            | Estructura: hace que todo sea "espacial"    | Es como el "Excel" espacial de R |
| `rnaturalearth` | Fuente de datos geogrÃ¡ficos en formatoÂ `sf` | Es como bajar un mapa listo      |
| `countrycode`   | Diccionario para traducir nombres de paÃ­ses | Es como un traductor de nombres  |

# Manos a la obra

## Exploremos

```{r, echo=TRUE}
world |> select(adm0_a3, geometry) |> 
  filter(adm0_a3 == "CHL")|> head(2)

```

```{r, echo=TRUE}
library(countrycode)

# Vector de paÃ­ses (algunos con nombres en espaÃ±ol)
paises <- c("Chile", "Argentina", "Brazil", "Estados Unidos", "Germany", "Reino Unido")

# Convertir a cÃ³digos ISO3
codigo_iso <- countrycode(paises, 
                          origin = "country.name", 
                          destination = "iso3c")

# Combinar en tabla
data.frame(pais = paises, iso3c = codigo_iso)

```

## Pero Â¿QuÃ© nos falta? IndexaciÃ³n de bases de datos

Cuando trabajamos con datos espaciales, es fundamental asegurarnos de que las bases compartan un mismo sistema de referencia espacial (CRS). AdemÃ¡s, debemos usar claves geogrÃ¡ficas comunes (ej. cÃ³digos de regiÃ³n, comuna o distrito) para poder hacer joins entre bases tabulares y espaciales.

VerificaciÃ³n con `st_crs()`. Uniones con `left_join()` y `inner_join()` usando cÃ³digos comunes.

*Â¿Coinciden los cÃ³digos geogrÃ¡ficos? Â¿Hay nombres de comunas mal escritos o duplicados? Â¿CuÃ¡ntos registros se pierden en el join?*

**Herramientas Ãºtiles:**

-   `anti_join()` para ver quÃ© quedÃ³ fuera.
-   `janitor::clean_names()` para estandarizar nombres de variables (mayÃºsculas, tildes, etc.)

## Datos ficticios (1)

```{r, echo=TRUE}

library(dplyr)
library(knitr)

economia <- tibble(
  pais = c("Chile", "Argentina", "PerÃº", "Brazil", "Colombia"),
  pib_per_capita = c(15000, 10500, 12000, 9800, 8700)
)

educacion <- tibble(
  pais = c("Chile", "Argentina", "Uruguay", "Brazil", "Ecuador"),
  anios_educacion = c(11.2, 10.5, 9.8, 8.9, 8.3)
)
```

::: columns
::: {.column width="50%"}
EducaciÃ³n

```{r}

kable(educacion)
```
:::

::: {.column width="50%"}
EconomÃ­a

```{r}
kable(economia)
```
:::
:::

## Datos ficticios (2)

Solo para los que se encuentran en el dataset: `inner_join`

```{r, echo=TRUE}
economia |> inner_join(educacion, by = "pais")

```

Solo para los datos que se encuentran en el dataset desde la posiciÃ³n en el cÃ³digo (left) : `left_join`

```{r, echo=TRUE}
economia |> left_join(educacion, by = "pais")
```

Solo para los datos que se encuentran en el dataset desde la posiciÃ³n en el cÃ³digo (right) : `right_join`

```{r, echo=TRUE}
economia |> right_join(educacion, by = "pais")

```

## Datos ficticios (3)

Se unen todos, incluso los con valores NA (full): `full_join`

```{r, echo=TRUE}
economia |> full_join(educacion, by = "pais")
```

Se verifica los que no pueden ser unidos correctamente en ambas bases: `anti_join`

```{r, echo=TRUE}
economia |> anti_join(educacion, by = "pais")
```

```{r, echo=TRUE}
educacion |> anti_join(economia, by = "pais")
```

## Datos ficticios (4)

```{r, echo=TRUE}
datos <- economia |> inner_join(educacion, by = "pais")
```

```{r, echo=TRUE}
# Paso 3: crear columna con cÃ³digo ISO-3 como 'iso3c'
datos <- datos %>%
  mutate(iso3c = countrycode(pais, origin = "country.name", destination = "iso3c"))

# Paso 4: obtener geometrÃ­a mundial
world <- ne_countries(scale = "medium", returnclass = "sf") %>%
  select(name, iso_a3, geometry)

# Paso 5: unir usando world como base principal
datos_geo <- inner_join(world, datos, by = c("iso_a3" = "iso3c")); datos_geo


```

```{r}
# Paso 1: Crear las bases de datos
# Paso 2: Unir las bases por paÃ­s

datos <- full_join(economia, educacion, by = "pais")

world <- ne_countries(scale = "medium", returnclass = "sf") %>%
  select(name, iso_a3, geometry)


# Paso 3: Agregar cÃ³digo ISO-3 para poder unir con geometrÃ­a
datos <- datos %>%
  mutate(iso3c = countrycode(pais, origin = "country.name", destination = "iso3c")) 

```

## Datos ficticios (5)

```{r, echo=TRUE}
datos |> glimpse()
world |> glimpse()

world2 <-world |> rename(iso3c = iso_a3)
datos_geo <- world2 |>  inner_join(datos, by = "iso3c")
```

```{r}
library(kableExtra)

datos_geo |> 
  #st_drop_geometry() |>
  kable() |>
  kable_styling(font_size = 21)

```

## Datos ficticios (6)

#### âœ…Â `geom_sf(aes(fill = pib_per_capita), color = "white")`

-   `geom_sf()`Â es el equivalente espacial deÂ `geom_bar()`Â oÂ `geom_point()`, pero para geometrÃ­a.

-   `fill = pib_per_capita`:Â **el color del paÃ­s depende del valor del PIB per cÃ¡pita**.

-   `color = "white"`: agrega bordes blancos entre paÃ­ses, para que se vean claramente separados.

```{r, echo=TRUE, fig.width=6, fig.height=4}
ggplot(datos_geo) +
  geom_sf(aes(fill = pib_per_capita), color = "white") +
  labs(title = "PIB per cÃ¡pita en paÃ­ses con datos educativos",
       fill = "PIB per cÃ¡pita") +
  theme_minimal()


```

## Datos ficticios (7)

```{r, echo=TRUE}
datos |> glimpse()
world |> glimpse()

world2 <-world |> rename(iso3c = iso_a3)
datos_geo <- world2 |>  full_join(datos, by = "iso3c")
```

```{r}
datos_geo |> head(5)|> 
  #st_drop_geometry() |>
  kable() |>
  kable_styling(font_size = 21)
```

## Datos ficticios 8

```{r}
ggplot(datos_geo) +
  geom_sf(aes(fill = pib_per_capita), color = "white") +
  labs(title = "PIB per cÃ¡pita en paÃ­ses con datos educativos",
       fill = "PIB per cÃ¡pita") +
  theme_minimal()
```

# Hasta acÃ¡: DUDAS.

## Chile Mapas

::: columns
::: {.column width="50%"}
![](images/22775997243.jpg){fig-align="center" width="347"}
:::

::: {.column width="50%"}
-   El paqueteÂ **`chilemapas`**Â es una herramienta diseÃ±ada especÃ­ficamente para R que permite acceder fÃ¡cilmente aÂ **mapas oficiales y actualizados de Chile**, listos para usar conÂ `ggplot2`Â yÂ `sf`.

-   ProporciÃ³n informaciÃ³n de: Provincias, Comunas, Regiones y Distrito electorales
:::
:::
