---
title: "An√°lisis cuantitativo del texto"
subtitle: "Datamining al textmining"
author: "Mat√≠as Deneken"
logo: "images/logo_ciir.jpg"
include-in-header:
  - text: |
      <style>
        .reveal .slides {
          padding-top: 0px !important;
        }
        .reveal h2 {
          margin-top: -20px !important;
        }
      </style>
footer: "Sesi√≥n 3: InteRculturales"
date: "2025-05-22"
date-format: long
format: 
  revealjs:
    incremental: true
    theme: simple
    width: 1600
    height: 900
    transition: slide
    slide-number: c/t
    chalkboard: true
    auto-stretch: false
callout-appearance: minimal
---

# Temario de hoy

1.  Introducci√≥n al SIG
2.  Paquetes en R
3.  Uni√≥n de bases de datos
4.  Pr√°ctica con datos ficticios
5.  ChileMapas
6.  C√≥digo pr√°ctico

## Objetivo principal: Replicar estos mapas

::: columns
::: {.column width="50%"}
#### Nube de palabras cuenta p√∫blica

![](images/humilde-objetivo1.png){fig-align="center" width="496"}
:::

::: {.column width="50%"}
#### Palabras mencionadas en Cuenta P√∫blica 

![](images/humilde-objetivo2.png){fig-align="center" width="496"}
:::
:::

```{r, eval=TRUE}
library(tidyverse)
library(sf)
library(countrycode)
library(chilemapas)
```

## Recapitulando...üìù

**Tidyverse**

Conjunto de paquetes de R dise√±ados para ciencia de datos. Incluye herramientas como ggplot2, dplyr, tidyr, readr, entre otros, que comparten una sintaxis coherente y principios comunes (funciones pipe ( `|>` o `%>%` ) y manipulaci√≥n de datos "ordenados").

```{r eval=FALSE, echo=TRUE}
head(starwars)
```

```{r, echo=TRUE}
names(starwars)
```

------------------------------------------------------------------------

## Recapitulando...üìù

**Tidyverse: `Select`**

Sirve para elegir columnas espec√≠ficas de un data frame.

```{r, echo=TRUE}
starwars %>%
  select(name, species, height, mass) |> head(2)
```

**Tidyverse: `Filter`**

Permite filtrar filas seg√∫n condiciones l√≥gicas.

```{r, echo=TRUE}
starwars %>% filter(species == "Human", mass > 80) |> head(2)
```

------------------------------------------------------------------------

## Recapitulando...üìù

**Tidyverse: `Mutate`**

Crea nuevas columnas o modifica variables existentes.

```{r, echo=TRUE}
starwars %>%
  mutate(imc_ficticio = mass / (height / 100)^2) %>%
  select(name, imc_ficticio) %>%
  arrange(desc(imc_ficticio)) |> 
  head(3)

```

------------------------------------------------------------------------

## Recapitulando...üìù

**Tidyverse: `Group_by` + `summarise`**

`Group_by`: Crea nuevas columnas o modifica variables existentes y `Summarise`: Genera res√∫menes estad√≠sticos por grupo (si se us√≥ group_by()) o para todo el conjunto.

```{r, echo=TRUE}
starwars %>% group_by(species) %>%
  summarise(
    promedio_altura = mean(height, na.rm = TRUE)
  ) %>%
  arrange(desc(promedio_altura)) |>  # Ordenar por n√∫mero de personajes
  head(3)


```

## Recapitulando ...üìù

```{r, echo=TRUE}
# Crear el gr√°fico
starwars %>%
  mutate(imc_ficticio = mass / (height / 100)^2) %>%
  select(name, imc_ficticio) %>%
  arrange(desc(imc_ficticio)) %>%
  head(3) %>%
  ggplot(aes(x = reorder(name, imc_ficticio), y = imc_ficticio)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(
    title = "Top 3 personajes con mayor IMC ficticio",
    x = "Nombre",
    y = "IMC"
  ) +
  theme_minimal()

```

## Recapitulando ...üìù

```{r, echo=TRUE}
starwars %>%
  filter(!is.na(height), !is.na(mass)) %>%
  ggplot(aes(x = height, y = mass)) +
  geom_point(alpha = 0.7, color = "navy") +
  labs(title = "Relaci√≥n entre estatura y peso en Star Wars",
       x = "Estatura (cm)", y = "Masa (kg)") +
  theme_minimal()

```

## Recapitulando ...üìù

```{r, echo=TRUE}
starwars %>%
  filter(!is.na(height)) %>%
  ggplot(aes(x = height)) +
  geom_density(fill = "skyblue", alpha = 0.6) +
  labs(title = "Distribuci√≥n de estatura en personajes de Star Wars",
       x = "Estatura (cm)", y = "Densidad") +
  theme_minimal()

```

## Sistema de Informaci√≥n Geogr√°fica (SIG)

Un **Sistema de Informaci√≥n Geogr√°fica (SIG)** es una herramienta tecnol√≥gica que permite **capturar, almacenar, analizar, visualizar y representar datos geogr√°ficos o espaciales**.

Combina informaci√≥n alfanum√©rica (como poblaci√≥n, ingresos o acceso a servicios) con su ubicaci√≥n en el espacio (como comunas, calles o regiones), lo que permite responder preguntas del tipo **‚Äú¬øD√≥nde ocurre qu√©...?‚Äù**.

-   Mapas tem√°ticos (ej. pobreza por comuna)

-   An√°lisis territorial (ej. acceso a servicios)

## Paquetes: üì¶ ¬øQu√© es `sf`?

`sf` es un **paquete de R** para trabajar con **datos espaciales** (geogr√°ficos) de manera moderna y eficiente. Su nombre viene de **"simple features"**, un est√°ndar internacional para representar datos espaciales (como puntos, l√≠neas o pol√≠gonos) en bases de datos y software. 

Te permite:

-   Leer y escribir **archivos espaciales** como Shapefiles, GeoJSON, KML, etc.

-   Unir datos geogr√°ficos con datos tabulares (como una comuna con su poblaci√≥n).

-   Hacer **an√°lisis espacial** (intersecciones, distancias, √°reas, etc.).

-   Visualizar mapas f√°cilmente con `ggplot2::geom_sf()` o `tmap`.

## Paquetes: üì¶ ¬øQu√© es `sf`?

### üß© Tipos de geometr√≠a

-   `POINT`: una ubicaci√≥n (ej: una escuela).

-   `LINESTRING`: una l√≠nea (ej: un r√≠o).

-   `POLYGON`: una superficie cerrada (ej: una comuna o pa√≠s).

-   `MULTIPOLYGON`: varios pol√≠gonos juntos (ej: Chile continental + Rapa Nui).

### üîß Funciones importantes del paquete `sf`

-   `st_read()`: lee archivos espaciales (como shapefiles).

-   `st_write()`: guarda archivos espaciales.

-   `st_geometry()`: accede a la geometr√≠a de un objeto.

-   `st_crs()`: inspecciona o define el sistema de coordenadas.

-   `st_transform()`: cambia la proyecci√≥n del mapa.

-   `st_join()`,`st_intersection()`: operaciones espaciales.

## Paquetes: üì¶ ¬øQu√© es`sf`?

### üó∫Ô∏è ¬øPor qu√© es √∫til?

Porque te permite combinar el mundo de la **estad√≠stica en R** con el an√°lisis geogr√°fico, sin salir del mismo entorno.

| Componente             | ¬øQu√© hace?                                              |
|------------------------|---------------------------------------------------------|
| **Clase especial**     | Le dice a R c√≥mo interpretar los datos como espaciales. |
| **Columna¬†`geometry`** | Guarda formas como puntos, pol√≠gonos, l√≠neas.           |
| **`CRS`¬†(proyecci√≥n)** | Define c√≥mo se ubica esa geometr√≠a en el planeta.       |
| **M√©todos especiales** | Permite hacer joins, distancias, transformaciones, etc. |

## Paquete: countrycode

El paquete `countrycode` permite convertir nombres de pa√≠ses entre distintos sistemas de codificaci√≥n est√°ndar. Es muy √∫til para unir bases de datos internacionales o conectar datos con geometr√≠as espaciales.

```{r, message=FALSE, eval=TRUE, echo=TRUE}
library(countrycode)
```

```{r, echo=TRUE}
countrycode("Chile", origin = "country.name", destination = "iso3c")
```

```{r, echo=TRUE}
names(countrycode::codelist)[1:10]
```

Algunas opciones de destination que puedes usar: \*

-   "iso3c" ‚Üí c√≥digo de 3 letras (ej: CHL)

-   "iso2c" ‚Üí c√≥digo de 2 letras (ej: CL) \* "continent" ‚Üí continente (ej: Americas)

-   "region" ‚Üí regi√≥n del mundo seg√∫n World Bank

-   "un.region.name" ‚Üí regi√≥n seg√∫n Naciones Unidas

-   "cldr.short.en" ‚Üí nombre corto en ingl√©s (ej: Chile)

## Paquete: countrycode

```{r}
library(countrycode)
library(knitr)

# Crear tabla con distintas codificaciones para "Chile"
tabla_chile <- data.frame(
  atributo = c("Nombre (original)", "C√≥digo ISO-3", "C√≥digo ISO-2", "Continente", "Regi√≥n", "Regi√≥n ONU", "Nombre corto en ingl√©s"),
  valor = c(
    "Chile",
    countrycode("Chile", "country.name", "iso3c"),
    countrycode("Chile", "country.name", "iso2c"),
    countrycode("Chile", "country.name", "continent"),
    countrycode("Chile", "country.name", "region"),
    countrycode("Chile", "country.name", "un.region.name"),
    countrycode("Chile", "country.name", "cldr.short.en")
  )
)

# Mostrar como tabla
kable(tabla_chile, caption = "Codificaciones para 'Chile' usando countrycode()")

```

## Paquete: R Natural Earth.

Es un paquete R que permite **descargar datos geogr√°ficos del mundo** (pa√≠ses, estados, l√≠neas costeras, r√≠os, etc.) desde el proyecto [Natural Earth](https://www.naturalearthdata.com/). Se usa mucho para crear mapas en R, especialmente con `sf` y `ggplot2`.

```{r, echo=TRUE}
library(rnaturalearth)

world <- ne_countries(scale = "medium", returnclass = "sf")

world |> select(iso_a3, geometry) |> head(2)
```

**Posee estad√≠sticas de inter√©s:**

-   Producto de Interno de Bruto

-   Regi√≥n econ√≥mica (BRICS, OCDE, etc)

-   Esperanza de vida

## Entonces....

| Paquete         | Rol en el flujo de trabajo                  | Analog√≠a                         |
|-----------------|---------------------------------------------|----------------------------------|
| `sf`            | Estructura: hace que todo sea "espacial"    | Es como el "Excel" espacial de R |
| `rnaturalearth` | Fuente de datos geogr√°ficos en formato¬†`sf` | Es como bajar un mapa listo      |
| `countrycode`   | Diccionario para traducir nombres de pa√≠ses | Es como un traductor de nombres  |

# Manos a la obra

## Exploremos

```{r, echo=TRUE}
world |> select(adm0_a3, geometry) |> 
  filter(adm0_a3 == "CHL")|> head(2)

```

```{r, echo=TRUE}
library(countrycode)

# Vector de pa√≠ses (algunos con nombres en espa√±ol)
paises <- c("Chile", "Argentina", "Brazil", "Estados Unidos", "Germany", "Reino Unido")

# Convertir a c√≥digos ISO3
codigo_iso <- countrycode(paises, 
                          origin = "country.name", 
                          destination = "iso3c")

# Combinar en tabla
data.frame(pais = paises, iso3c = codigo_iso)

```

## Pero ¬øQu√© nos falta? Indexaci√≥n de bases de datos

Cuando trabajamos con datos espaciales, es fundamental asegurarnos de que las bases compartan un mismo sistema de referencia espacial (CRS). Adem√°s, debemos usar claves geogr√°ficas comunes (ej. c√≥digos de regi√≥n, comuna o distrito) para poder hacer joins entre bases tabulares y espaciales.

Verificaci√≥n con `st_crs()`. Uniones con `left_join()` y `inner_join()` usando c√≥digos comunes.

*¬øCoinciden los c√≥digos geogr√°ficos? ¬øHay nombres de comunas mal escritos o duplicados? ¬øCu√°ntos registros se pierden en el join?*

**Herramientas √∫tiles:**

-   `anti_join()` para ver qu√© qued√≥ fuera.
-   `janitor::clean_names()` para estandarizar nombres de variables (may√∫sculas, tildes, etc.)

## Datos ficticios (1)

```{r, echo=TRUE}

library(dplyr)
library(knitr)

economia <- tibble(
  pais = c("Chile", "Argentina", "Peru", "Brazil", "Colombia"),
  pib_per_capita = c(15000, 10500, 12000, 9800, 8700)
)

educacion <- tibble(
  pais = c("Chile", "Argentina", "Uruguay", "Brazil", "Ecuador"),
  anios_educacion = c(11.2, 10.5, 9.8, 8.9, 8.3)
)
```

::: columns
::: {.column width="50%"}
Educaci√≥n

```{r}

kable(educacion)
```
:::

::: {.column width="50%"}
Econom√≠a

```{r}
kable(economia)
```
:::
:::

## Datos ficticios (2)

Solo para los que se encuentran en el dataset: `inner_join`

```{r, echo=TRUE}
economia |> inner_join(educacion, by = "pais")

```

Solo para los datos que se encuentran en el dataset desde la posici√≥n en el c√≥digo (left) : `left_join`

```{r, echo=TRUE}
economia |> left_join(educacion, by = "pais")
```

Solo para los datos que se encuentran en el dataset desde la posici√≥n en el c√≥digo (right) : `right_join`

```{r, echo=TRUE}
economia |> right_join(educacion, by = "pais")

```

## Datos ficticios (3)

Se unen todos, incluso los con valores NA (full): `full_join`

```{r, echo=TRUE}
economia |> full_join(educacion, by = "pais")
```

Se verifica los que no pueden ser unidos correctamente en ambas bases: `anti_join`

```{r, echo=TRUE}
economia |> anti_join(educacion, by = "pais")
```

```{r, echo=TRUE}
educacion |> anti_join(economia, by = "pais")
```

## Datos ficticios (4)

```{r, echo=TRUE}
datos <- economia |> inner_join(educacion, by = "pais")
```

```{r, echo=TRUE}
# Paso 3: crear columna con c√≥digo ISO-3 como 'iso3c'
datos <- datos %>%
  mutate(iso3c = countrycode(pais, origin = "country.name", destination = "iso3c"))

# Paso 4: obtener geometr√≠a mundial
world <- ne_countries(scale = "medium", returnclass = "sf") %>%
  select(name, iso_a3, geometry)

# Paso 5: unir usando world como base principal
datos_geo <- inner_join(world, datos, by = c("iso_a3" = "iso3c")); datos_geo


```

```{r}
# Paso 1: Crear las bases de datos
# Paso 2: Unir las bases por pa√≠s

datos <- full_join(economia, educacion, by = "pais")

world <- ne_countries(scale = "medium", returnclass = "sf") %>%
  select(name, iso_a3, geometry)


# Paso 3: Agregar c√≥digo ISO-3 para poder unir con geometr√≠a
datos <- datos %>%
  mutate(iso3c = countrycode(pais, origin = "country.name", destination = "iso3c")) 

```

## Datos ficticios (5)

```{r, echo=TRUE}
datos |> glimpse()
world |> glimpse()

world2 <-world |> rename(iso3c = iso_a3)
datos_geo <- world2 |>  inner_join(datos, by = "iso3c")
```

```{r}
library(kableExtra)

datos_geo |> 
  #st_drop_geometry() |>
  kable() |>
  kable_styling(font_size = 21)

```

## Datos ficticios (6)

‚úÖ¬†`geom_sf(aes(fill = pib_per_capita), color = "white")`

-   `geom_sf()`¬†es el equivalente espacial de¬†`geom_bar()`¬†o¬†`geom_point()`, pero para geometr√≠a.

-   `fill = pib_per_capita`:¬†**el color del pa√≠s depende del valor del PIB per c√°pita**.

-   `color = "white"`: agrega bordes blancos entre pa√≠ses, para que se vean claramente separados.

```{r, echo=TRUE, fig.width=6, fig.height=4}
ggplot(datos_geo) +
  geom_sf(aes(fill = pib_per_capita), color = "white") +
  labs(title = "PIB per c√°pita en pa√≠ses con datos educativos",
       fill = "PIB per c√°pita") +
  theme_minimal()


```

## Datos ficticios (7)

**¬øY si hubiera hecho un full_join?**

```{r, echo=TRUE}
datos |> glimpse()
world |> glimpse()

world2 <-world |> rename(iso3c = iso_a3)
datos_geo <- world2 |>  full_join(datos, by = "iso3c")
```

```{r}
datos_geo |> head(5)|> 
  #st_drop_geometry() |>
  kable() |>
  kable_styling(font_size = 21)
```

## Datos ficticios (8): Efecto del full join

```{r, echo=TRUE}
ggplot(datos_geo) +
  geom_sf(aes(fill = pib_per_capita), color = "white") +
  labs(title = "PIB per c√°pita en pa√≠ses con datos educativos",
       fill = "PIB per c√°pita") +
  theme_minimal()
```

# Hasta ac√°: DUDAS.

## Chile Mapas

::: columns
::: {.column width="50%"}
![](images/geografia.jpg){fig-align="center" width="312"}
:::

::: {.column width="50%"}
-   El paquete¬†**`chilemapas`**¬†es una herramienta dise√±ada espec√≠ficamente para R que permite acceder f√°cilmente a¬†**mapas oficiales y actualizados de Chile**, listos para usar con¬†`ggplot2`¬†y¬†`sf`.

-   Proporci√≥n informaci√≥n de: Provincias, Comunas, Regiones y Distrito electorales
:::
:::

## ChileMapas

```{r, echo=TRUE}
mapa_comunas <- chilemapas::mapa_comunas

mapa_comunas |> head(10)
```

## Gr√°fico Chile

```{r, echo=TRUE}
grafico_comunas <- mapa_comunas |> 
  st_set_geometry(mapa_comunas$geometry) |> # asignar geometr√≠a
  ggplot() + # gr√°fico
  geom_sf() # capa geom√©trica

grafico_comunas +
  theme_classic()
```

## Chile Mapas: Regiones

El paquete¬†`{sf}`¬†facilita en gran medida el trabajo con datos geogr√°ficos, especialmente en lo que respecta a operaciones espaciales como la¬†**fusi√≥n de pol√≠gonos adyacentes**.

En este caso, utilizamos¬†`group_by()`¬†para agrupar las observaciones seg√∫n la variable¬†`codigo_region`, Luego, aplicamos¬†`summarize()`¬†junto a la funci√≥n¬†`sf::st_union()`¬†para combinar los pol√≠gonos de las comunas dentro de cada grupo, generando as√≠ un nuevo conjunto de¬†**pol√≠gonos regionales**

```{r, echo=TRUE}
mapa_regiones <- mapa_comunas |> 
  group_by(codigo_region) |> 
  summarize(geometry = st_union(geometry)) # resumir los datos agrupados uni√©ndolos

mapa_regiones |> head(2)
```

## ChileMapas: Regiones

```{r}
grafico_regiones <- mapa_regiones |> 
  st_set_geometry(mapa_regiones$geometry) |> # especificar la geometr√≠a del mapa
  ggplot() + # graficar
  geom_sf() 

grafico_regiones +
  theme_classic()
```

## ChileMapas: Filtremos

```{r, echo=TRUE}
mapa <- chilemapas::mapa_comunas |> 
  left_join(
    chilemapas::codigos_territoriales |> 
      select(matches("comuna")), 
    by = "codigo_comuna") |> 
  filter(codigo_region=="08")

mapa |> head(2)
```

```{r, echo=TRUE}
mapa_datos <- mapa |> 
  # crear una variable para comunas espec√≠ficas
  mutate(variable = case_when(nombre_comuna == "Chiguayante" ~ "Fui",
                              nombre_comuna == "San Pedro de la Paz" ~ "Fui",
                              nombre_comuna == "Coronel" ~ "Fui",
                              nombre_comuna == "Hualpen" ~ "No fui",
                              nombre_comuna == "Lota" ~ "Fui",
                              nombre_comuna == "Concepcion" ~ "Fui",
                              nombre_comuna == "Santa Juana" ~ "No fui")) |> 
  select(nombre_comuna, codigo_comuna, variable, geometry)

mapa_datos |> head(1)
```

## ChileMapas: Visualizar

```{r, echo=TRUE}
# visualizar
mapa_datos |> 
  ggplot() +
  geom_sf(aes(geometry = geometry, 
              fill = variable), #usamos la variable que creamos como relleno de las comunas
          col = "white") +
  theme_void()
```

## ChileMapas: Un ejemplo a las regiones

```{r, echo=TRUE}
mapa_regiones |> 
  st_set_geometry(mapa_regiones$geometry) |> head(3)
```

```{r, echo=TRUE}
mapa_regiones <- mapa_regiones %>%
  mutate(nombre_region = case_when(
    codigo_region == "01" ~ "Regi√≥n de Tarapac√°",
    codigo_region == "02" ~ "Regi√≥n de Antofagasta",
    codigo_region == "03" ~ "Regi√≥n de Atacama",
    codigo_region == "04" ~ "Regi√≥n de Coquimbo",
    codigo_region == "05" ~ "Regi√≥n de Valpara√≠so",
    codigo_region == "06" ~ "Regi√≥n del Libertador General Bernardo O'Higgins",
    codigo_region == "07" ~ "Regi√≥n del Maule",
    codigo_region == "08" ~ "Regi√≥n del Biob√≠o",
    codigo_region == "09" ~ "Regi√≥n de La Araucan√≠a",
    codigo_region == "10" ~ "Regi√≥n de Los Lagos",
    codigo_region == "11" ~ "Regi√≥n de Ays√©n del General Carlos Ib√°√±ez del Campo",
    codigo_region == "12" ~ "Regi√≥n de Magallanes y de la Ant√°rtica Chilena",
    codigo_region == "13" ~ "Regi√≥n Metropolitana de Santiago",
    codigo_region == "14" ~ "Regi√≥n de Los R√≠os",
    codigo_region == "15" ~ "Regi√≥n de Arica y Parinacota",
    codigo_region == "16" ~ "Regi√≥n de √ëuble",
    TRUE ~ NA_character_
  ))

```

## ChileMapas: Un ejemplo a las regiones

```{r}
library(readxl)
perros_callejeros <- read_excel("bbdd/perros_callejeros.xlsx") |> select(-nombre_region)
```

```{r, echo=TRUE}
perros_callejeros |> head(2)
```

```{r, echo=TRUE}
mapa_regiones2 <- mapa_regiones |> inner_join(perros_callejeros, by = "codigo_region") |> glimpse()
```

```{r}
mapa_regiones2 
```

## ChileMapas: Un ejemplo a las regiones

::: columns
::: {.column width="50%"}
```{r, echo=TRUE}
mapa_regiones2 |> 
  st_set_geometry(mapa_regiones$geometry) |> 
  # especificar la geometr√≠a del mapa
  ggplot(aes(geometry = geometry,
             fill = perros_calle_por_1000hab
             )) + # graficar
  geom_sf() 
```
:::

::: {.column width="50%"}
```{r, echo=TRUE}
mapa_regiones2 |> 
  st_set_geometry(mapa_regiones$geometry) |> 
  ggplot(aes(geometry = geometry,
             fill = perros_calle_por_1000hab)) +
  geom_sf(color = "gray90") +
  coord_sf(xlim = c(-77, -65)) +
scale_fill_gradient(
  low = "#8EC3E2",
  high = "#BB1515",
  name = "Perros / 1000 hab."
) +
  theme_minimal() +
  labs(
    title = "Perros callejeros",
    subtitle = "En Chile por cada mil habitantes"
  )

```
:::
:::

## Fuente utilizadas

1.  [Tutorial BastiMapache](https://rpubs.com/bastimapache/mapa_urbano_rm)

# Vamos al c√≥digo!
